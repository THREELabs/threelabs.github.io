<!DOCTYPE html>
<html>
<head>
    <title>Ultima Brawler</title>
    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <style>
        :root {
            --viewport-width: 700px;
            --viewport-height: 500px;
            --ui-height: 160px;
            --world-width: 2200px; 
            --world-height: 1500px;
        }
        body { font-family: 'Courier New', Courier, monospace; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; background-color: #1a1a1a; color: #fff; }
        .screen { text-align: center; }
        #game-container { display: none; }
        #login-screen input, #login-screen button { font-size: 16px; padding: 8px; margin: 5px; background-color: #444; color: #fff; border: 1px solid #666; cursor: pointer; }
        #login-screen button:hover { background-color: #555; }
        #status-message { color: #ffaeae; min-height: 20px; }
        #game-world { width: var(--viewport-width); height: var(--viewport-height); position: relative; overflow: hidden; border: 2px solid #666; cursor: crosshair; }
        #world-container { width: var(--world-width); height: var(--world-height); position: absolute; background-color: #1a472a; }
        #ui-panel { width: var(--viewport-width); height: var(--ui-height); background-color: #2a2a2a; border: 2px solid #666; border-top: none; display: flex; flex-direction: column; padding: 5px; box-sizing: border-box; }
        .map-feature { position: absolute; box-sizing: border-box; }
        #bridge-zone { position: absolute; top: 0; left: 700px; width: 1500px; height: 100%; }
        #water-north { top: 0; left: 0; width: 100%; height: 650px; background-color: #1a3a5a; }
        #britain-bridge { top: 650px; left: 0; width: 100%; height: 200px; background-color: #654321; border-top: 5px solid #4a3018; border-bottom: 5px solid #4a3018; position: relative; }
        #bridge-planks { width: 100%; height: 100%; background-image: repeating-linear-gradient(90deg, rgba(0,0,0,0.1) 20px, transparent 20px, transparent 40px); }
        
        #britain-bridge::before, #britain-bridge::after {
            content: '';
            position: absolute;
            left: 0;
            width: 100%;
            height: 10px;
            background-color: #4a3018;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 2;
        }
        #britain-bridge::before { top: 0; }
        #britain-bridge::after { bottom: 0; }
        
        #water-south { top: 850px; left: 0; width: 100%; height: 650px; background-color: #1a3a5a; }
        
        /* --- Building Style Overhaul --- */
        .building {
            position: absolute;
            box-sizing: border-box;
            border: 2px solid #3a2d1a;
            box-shadow: 5px 5px 10px rgba(0,0,0,0.4);
            z-index: 3;
        }
        /* Generic Roof */
        .building::before {
            content: '';
            position: absolute;
            top: -39px;
            left: -3px;
            width: calc(100% + 4px);
            height: 35px;
            background-color: #A52A2A; /* Brown roof color */
            border: 2px solid #3a2d1a;
            clip-path: polygon(0% 100%, 50% 0%, 100% 100%);
            z-index: 4;
        }
        /* Generic Door */
        .building::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 25px;
            height: 40px;
            background-color: #5C2E00; /* Dark wood color */
            border-top: 2px solid #3a2d1a;
            border-left: 2px solid #3a2d1a;
            border-right: 2px solid #3a2d1a;
            z-index: 5;
        }

        #bank {
            top: 520px; left: 300px; width: 160px; height: 100px;
            background: linear-gradient(45deg, #a1a1a1, #cccccc); /* Stone look */
            border-color: #444;
        }
        #bank::before { /* Bank has a flatter roof */
             background-color: #696969;
             border-color: #444;
             top: -30px;
             height: 25px;
        }
        #bank::after { /* Taller bank door */
            height: 50px;
            width: 30px;
            background-color: #4a3018;
        }

        #blacksmith {
            top: 500px; left: 500px; width: 120px; height: 120px;
            background-color: #696969; /* DimGray */
            border-color: #333;
        }
        #blacksmith::before { /* Blacksmith roof */
            background-color: #4d4d4d;
            border-color: #333;
        }
        .chimney {
            position: absolute;
            right: 10px;
            top: -50px;
            width: 20px;
            height: 40px;
            background-color: #5a5a5a;
            border: 2px solid #333;
            z-index: 2;
        }
        
        #healers-hut {
            top: 530px; left: 180px; width: 80px; height: 70px;
            background-color: #D2B48C; /* Tan */
            border-color: #8B4513;
        }
        #healers-hut::before { /* Healer's Hut roof */
            background-color: #c14444; /* Reddish roof */
        }
        /* --- End Building Style Overhaul --- */

        .game-object { width: 30px; height: 30px; position: absolute; transition: box-shadow 0.3s ease-in-out; box-sizing: border-box; }
        .player-object { border: 2px solid #111; border-radius: 50%; }
        .local-player { background-color: #4a90e2; z-index: 10; }
        .remote-player { background-color: #d0021b; z-index: 9; }
        .npc-object { background-color: #7ed321; border: 2px solid #111; border-radius: 10px; z-index: 5; transition: opacity 0.5s ease-in-out; }
        .gold-pile { background-color: #ffd700; width: 15px; height: 15px; border-radius: 50%; border: 1px solid #b8860b; z-index: 1; box-shadow: 0 0 5px #ffd700; }
        #shrine { position: absolute; top: 720px; left: 45px; width: 60px; height: 60px; background-color: #c0c0c0; border: 3px solid #f0e68c; border-radius: 50%; box-shadow: 0 0 15px #ffffff; z-index: 2; }
        #safe-zone { position: absolute; top: 0; left: 0; width: 150px; height: 100%; background-color: rgba(173, 216, 230, 0.3); border-right: 3px solid #add8e6; box-sizing: border-box; z-index: 0; }
        #idle-player-area { position: absolute; top: 10px; left: 10px; width: 130px; height: 200px; background-color: rgba(128, 0, 128, 0.2); border: 2px dashed rgba(128, 0, 128, 0.5); box-sizing: border-box; z-index: 0; }
        #vendor-npc { position: absolute; top: 400px; left: 55px; width: 40px; height: 40px; background-color: #8a2be2; border: 2px solid #4b0082; border-radius: 3px; z-index: 5; cursor: pointer; }
        .ghost { opacity: 0.5; filter: grayscale(80%); cursor: default !important; }
        .name-tag { 
            position: absolute; 
            bottom: 100%; 
            left: 50%; 
            transform: translateX(-50%); 
            background-color: rgba(0, 0, 0, 0.7); 
            color: white; 
            padding: 2px 5px; 
            font-size: 12px; 
            white-space: nowrap; 
            margin-bottom: 15px; 
            opacity: 1; 
            transition: opacity 0.5s ease-in-out; 
            user-select: none;
            pointer-events: none;
        }
        .speech-bubble { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 35px; background-color: rgba(255, 255, 255, 0.9); color: #111; padding: 5px 10px; border-radius: 10px; font-size: 14px; width: 100px; text-align: left; opacity: 0; transition: opacity 0.3s ease-in-out; pointer-events: none; white-space: normal; overflow-wrap: break-word; }
        .in-combat .name-tag { opacity: 0; }
        .health-bar { position: absolute; bottom: -15px; left: 50%; transform: translateX(-50%); width: 34px; height: 5px; background-color: #555; border: 1px solid #111; }
        .health-bar-inner { width: 100%; height: 100%; background-color: #7ed321; transition: width 0.2s linear; }
        .player-object.speed-buff { box-shadow: 0 0 15px 5px #4a90e2; }
        .player-object.damage-buff { box-shadow: 0 0 15px 5px #e24a4a; }
        .player-object.poisoned, .npc-object.poisoned { box-shadow: 0 0 15px 5px #4CAF50; }
        #player-stats { color: #f0e68c; padding: 4px; display: flex; justify-content: space-around; font-size: 16px; border-bottom: 1px solid #444; }
        #chat-log { flex-grow: 1; overflow-y: scroll; background-color: #1e1e1e; padding: 5px; font-size: 14px; text-align: left; }
        #chat-log p { margin: 0 0 4px 0; }
        .system-msg { color: #88aaff; font-style: italic; }
        .my-msg { color: #aaeebb; }
        .their-msg { color: #ffb4b4; }
        #chat-input { border: 1px solid #666; background-color: #333; color: #fff; padding: 8px; margin-top: 5px; outline: none; }
        #vendor-menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #2a2a2a; border: 2px solid #666; padding: 20px; z-index: 100; box-shadow: 0 0 20px black; }
        #vendor-menu h3 { margin-top: 0; }
        #vendor-menu table { border-collapse: collapse; width: 100%; }
        #vendor-menu td, #vendor-menu th { border: 1px solid #444; padding: 8px; text-align: left; }
        #vendor-menu button { background-color: #4a90e2; color: white; border: none; padding: 5px 10px; cursor: pointer; }
        #vendor-menu button:hover { background-color: #6aa0e5; }
        #close-vendor-btn { background-color: #d0021b; float: right; }
        .damage-flash { animation: damage-shake 0.4s cubic-bezier(.36,.07,.19,.97); }
        
        @keyframes damage-shake {
            0%, 100% {
                filter: none;
            }
            50% {
                filter: brightness(1.8) drop-shadow(0 0 3px #ff4d4d);
            }
        }

        .melee-attack-lunge {
            animation: melee-lunge 0.3s ease-out;
        }
        @keyframes melee-lunge {
            0% { transform: scale(1); }
            50% { transform: scale(1.1) translateY(-2px); }
            100% { transform: scale(1); }
        }

        #target-display { display: none; padding: 5px; background-color: #111; border-bottom: 1px solid #444; text-align: center; color: #ffdddd; font-size: 16px; }
        #target-health-bar { width: 150px; height: 10px; background-color: #555; border: 1px solid #111; margin: 4px auto 0 auto; }
        #target-health-bar-inner { width: 100%; height: 100%; background-color: #d0021b; transition: width 0.2s linear; }
        .targeted-entity { box-shadow: 0 0 15px 5px #f0e68c !important; border-radius: 50%; }
        .npc-object.targeted-entity { border-radius: 10px; }
        #player-mana { color: #88aaff; }
        .spell-text { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 40px; padding: 3px 8px; background-color: rgba(60, 0, 100, 0.8); color: #f0e68c; font-size: 14px; font-weight: bold; white-space: nowrap; border-radius: 5px; border: 1px solid #4b0082; opacity: 0; transition: opacity 0.3s ease-in-out, margin-bottom 0.3s ease-in-out; pointer-events: none; z-index: 25; }
        .spell-projectile { position: absolute; width: 20px; height: 20px; text-align: center; line-height: 20px; font-size: 20px; pointer-events: none; z-index: 50; transition: transform 0.2s; }
        
        .fizzle-effect {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #888;
            border-radius: 50%;
            pointer-events: none;
            z-index: 99;
            animation: smoke-puff 0.7s ease-out forwards;
        }
        @keyframes smoke-puff {
            from {
                transform: scale(0.2);
                opacity: 0.7;
            }
            to {
                transform: scale(1.3);
                opacity: 0;
            }
        }
        
        #sailing-boat {
            position: absolute;
            width: 60px;
            height: 25px;
            background-color: #8B4513;
            border: 2px solid #5C2E00;
            border-bottom-left-radius: 40%;
            border-bottom-right-radius: 40%;
            z-index: 2;
            transition: transform 0.5s ease-in-out;
        }
        #sailing-boat::before { /* Mast */
            content: '';
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 50px;
            background-color: #5C2E00;
        }
        #sailing-boat::after { /* Sail */
            content: '';
            position: absolute;
            bottom: 25px;
            left: 50%;
            width: 35px;
            height: 40px;
            background-color: #f5f5dc;
            clip-path: polygon(0 0, 100% 50%, 0 100%);
        }
    </style>
</head>
<body>
    <div id="login-screen" class="screen">
        <h2>Ultima Brawler</h2>
        <input type="text" id="player-name-input" placeholder="Enter Your Name">
        <br>
        <button id="join-game-btn">Find or Create Game</button>
        <p id="status-message">Initializing...</p>
    </div>

    <div id="game-container" class="screen">
        <div id="game-world">
            <div id="world-container">
                <div id="bridge-zone" class="map-feature"><div id="water-north" class="map-feature"></div><div id="britain-bridge" class="map-feature"><div id="bridge-planks"></div></div><div id="water-south" class="map-feature"></div></div>
                <div id="idle-player-area" class="map-feature"></div>
                <div id="shrine"></div>
                <div id="safe-zone"></div>
                <div id="vendor-npc" title="Potion Vendor"></div>
                <div id="bank" class="building"></div>
                <div id="blacksmith" class="building"><span class="chimney"></span></div>
                <div id="healers-hut" class="building"></div>
                <div id="sailing-boat" class="map-feature"></div>
            </div>
            <div id="vendor-menu">
                <h3>Potion Vendor</h3><button id="close-vendor-btn">X</button>
                <table>
                    <thead><tr><th>Item</th><th>Description</th><th>Cost</th><th>Buy</th></tr></thead>
                    <tbody>
                        <tr><td>Healing Potion</td><td>Restores 40 health. (Press 6)</td><td>50 G</td><td><button class="buy-btn" data-item="health_potion">Buy</button></td></tr>
                        <tr><td>Speed Potion</td><td>+50% speed for 20s.</td><td>75 G</td><td><button class="buy-btn" data-item="speed_potion">Buy</button></td></tr>
                        <tr><td>Damage Potion</td><td>+5 damage for 20s.</td><td>100 G</td><td><button class="buy-btn" data-item="damage_potion">Buy</button></td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div id="ui-panel">
            <div id="player-stats">
                <span id="player-gold">Gold: 0</span>
                <span id="player-mana">Mana: 100</span>
                <span id="player-inventory"></span>
            </div>
            <div id="target-display">
                <span id="target-name"></span>
                <div id="target-health-bar">
                    <div id="target-health-bar-inner"></div>
                </div>
            </div>
            <div id="chat-log"></div>
            <input type="text" id="chat-input" placeholder="Press Enter to chat... (try /top)" autocomplete="off">
        </div>
    </div>

    <script>
        const loginScreen = document.getElementById('login-screen'), gameContainer = document.getElementById('game-container'), playerNameInput = document.getElementById('player-name-input'), joinGameBtn = document.getElementById('join-game-btn'), statusMessage = document.getElementById('status-message'), world = document.getElementById('game-world'), worldContainer = document.getElementById('world-container'), chatLog = document.getElementById('chat-log'), chatInput = document.getElementById('chat-input'), playerGoldDisplay = document.getElementById('player-gold'), playerInventoryDisplay = document.getElementById('player-inventory'), vendorNpc = document.getElementById('vendor-npc'), vendorMenu = document.getElementById('vendor-menu'), closeVendorBtn = document.getElementById('close-vendor-btn'),
              targetDisplay = document.getElementById('target-display'), targetNameDisplay = document.getElementById('target-name'), targetHealthBarInner = document.getElementById('target-health-bar-inner');
        
        const HOST_ID = 'ultima-brawler-game-host-v2';
        let peer, localPlayerId, isHost = false, currentTargetId = null;
        const players = {}, connections = {}, npcs = {}, worldItems = {}, projectiles = {};

        const WORLD_WIDTH_ACTUAL = 2200, WORLD_HEIGHT_ACTUAL = 1500, BRIDGE_ZONE_START_X = 700, BRIDGE_TOP_Y = 650, BRIDGE_BOTTOM_Y = 850;
        let cameraX = 0, cameraY = 0;
        
        const keysPressed = {}; let attackCooldown = false;
        
        let isMouseDown = false;
        let isMovingWithMouse = false;
        let mouseTargetWorldPos = { x: null, y: null };
        let isAutoAttacking = false;

        const PLAYER_SIZE = 30, PLAYER_RADIUS = PLAYER_SIZE / 2, MAX_HEALTH = 100, PLAYER_BASE_SPEED = 8, PLAYER_BASE_ATTACK_DAMAGE = 10;
        const ATTACK_RANGE = 60, SLIME_GOLD_DROP = 10, GOLD_PILE_SIZE = 15, GOLD_DROP_RADIUS = 40, ATTACK_COOLDOWN_MS = 1000;
        const NPC_SLIME_HEALTH = 30, NPC_SLIME_DAMAGE = 5, NPC_SLIME_SPEED = 2, NPC_AGGRO_RANGE = 200, NPC_ATTACK_RANGE = 40, MAX_NPCS = 10;
        const SHRINE_X = 45, SHRINE_Y = 720, SHRINE_SIZE = 60, SHRINE_RADIUS = SHRINE_SIZE / 2;
        const RESURRECTION_TIME = 3000, SAFE_ZONE_START_X = 0, SAFE_ZONE_END_X = 150;
        const COMBAT_TIMEOUT = 5000, IDLE_TIMEOUT = 30000;
        const IDLE_ZONE = { x: 10, y: 10, width: 130, height: 200 };
        const VENDOR_X = 55, VENDOR_Y = 400, VENDOR_SIZE = 40, VENDOR_INTERACT_RANGE = 80;
        const HEALING_POTION_AMOUNT = 40, BUFF_DURATION = 20000;
        const VENDOR_ITEMS = { health_potion: { cost: 50 }, speed_potion: { cost: 75 }, damage_potion: { cost: 100 } };
        const TITLE_DEFINITIONS = { "the Victim": { requirement: 'deaths', value: 5 }, "the Unlucky": { requirement: 'deaths', value: 15 }, "the Hunter": { requirement: 'pveKills', value: 10 }, "the Exterminator": { requirement: 'pveKills', value: 50 }, "the Brawler": { requirement: 'pvpKills', value: 3 }, "the Duelist": { requirement: 'pvpKills', value: 10 }, "the Murderer": { requirement: 'pvpKills', value: 25 }, };
        
        const BUILDINGS = [
            { id: 'bank', x: 300, y: 520, width: 160, height: 100 },
            { id: 'blacksmith', x: 500, y: 500, width: 120, height: 120 },
            { id: 'healers-hut', x: 180, y: 530, width: 80, height: 70 }
        ];

        const MAX_MANA = 100, MANA_REGEN_RATE = 1, MANA_REGEN_INTERVAL = 1000;
        const SPELL_RANGE = 350, PROJECTILE_SPEED = 600;
        
        const SPELLS = {
            'poison':      { name: 'Poison',      words: 'In Nox',       manaCost: 9,  castTime: 1500, damage: 0,  key: '1' },
            'lightning':   { name: 'Lightning',   words: 'Por Ort Grav', manaCost: 10, castTime: 2200, damage: 12, key: '2' },
            'magic_arrow': { name: 'Magic Arrow', words: 'In Por Ylem', manaCost: 4,  castTime: 700,  damage: 1,  key: '3' },
            'flamestrike': { name: 'Flamestrike', words: 'Kal Vas Flam', manaCost: 40, castTime: 3500, damage: 25, key: '4' }
        };

        const INTERPOLATION_FACTOR = 0.2;
        
        const sailingBoat = document.getElementById('sailing-boat');
        let boatX = 800;
        const boatY = 300;
        let boatDirection = 1;

        function setMouseTarget(e) {
            const worldRect = world.getBoundingClientRect();
            mouseTargetWorldPos.x = e.clientX - worldRect.left + cameraX;
            mouseTargetWorldPos.y = e.clientY - worldRect.top + cameraY;
        }

        // --- INITIALIZATION ---
        function initialize() {
            joinGameBtn.addEventListener('click', onJoinGameClick);
            chatInput.addEventListener('keydown', onChatSubmit);
            window.addEventListener('keydown', e => { const key = e.key.toLowerCase(); keysPressed[key] = true; handleKeyPress(e); });
            window.addEventListener('keyup', e => { keysPressed[e.key.toLowerCase()] = false; });
            world.addEventListener('click', onWorldClick);
            world.addEventListener('contextmenu', e => e.preventDefault());

            world.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const me = players[localPlayerId];
                if (!me || document.activeElement === chatInput || vendorMenu.style.display === 'block') return;
                isMouseDown = true;
                setMouseTarget(e);
                isMovingWithMouse = true;
            });

            window.addEventListener('mouseup', (e) => {
                if (e.button !== 0) return;
                isMouseDown = false;
                isMovingWithMouse = false;
            });

            world.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    setMouseTarget(e);
                    isMovingWithMouse = true;
                }
            });

            closeVendorBtn.addEventListener('click', () => vendorMenu.style.display = 'none');
            document.querySelectorAll('.buy-btn').forEach(btn => btn.addEventListener('click', () => sendData({ type: 'buy-item', itemId: btn.dataset.item })));
            statusMessage.textContent = 'Ready. Enter a name and join.';
        }
        
        function isPositionInWater(x, y) { if (x < BRIDGE_ZONE_START_X - PLAYER_SIZE) return false; if (y < BRIDGE_TOP_Y || y + PLAYER_SIZE > BRIDGE_BOTTOM_Y) return true; return false; }
        function isPositionInSafeZone(x) { return x >= SAFE_ZONE_START_X && x < SAFE_ZONE_END_X; }
        
        function isPositionInBuilding(x, y) {
            for (const building of BUILDINGS) {
                if (checkBuildingCollision(x, y, building)) {
                    return true;
                }
            }
            return false;
        }

        function getSafeSpawnPoint() { 
            let x, y; 
            do { 
                x = Math.random() * (WORLD_WIDTH_ACTUAL - PLAYER_SIZE); 
                y = Math.random() * (WORLD_HEIGHT_ACTUAL - PLAYER_SIZE); 
            } while (isPositionInWater(x, y) || isPositionInSafeZone(x) || isPositionInBuilding(x, y)); 
            return { x, y }; 
        }
        
        function onJoinGameClick() { 
            const name = playerNameInput.value || `Player_${Math.floor(Math.random() * 1000)}`; 
            joinGameBtn.disabled = true; 
            statusMessage.textContent = 'Attempting to create game...'; 
            peer = new Peer(HOST_ID); 
            peer.on('open', (id) => { 
                // HOST PATH: This code runs if we successfully claimed the HOST_ID
                console.log(`[SUCCESS] I am the HOST with ID: ${id}`); 
                statusMessage.textContent = 'Game created! Waiting for players...'; 
                isHost = true; 
                setInterval(updateManaRegen, MANA_REGEN_INTERVAL); 
                localPlayerId = id; 
                peer.on('connection', setupConnection); 
                finalizeGameEntry(name); 
            }); 
            peer.on('error', (err) => { 
                if (err.type === 'unavailable-id') { 
                    // CLIENT PATH: This code runs if the HOST_ID is already taken.
                    console.log(`[INFO] Host already exists. Connecting as a client...`); 
                    statusMessage.textContent = 'Game found! Connecting as client...'; 
                    peer.destroy(); 
                    peer = new Peer(); // Create a peer with a random ID for the client
                    peer.on('open', (id) => { 
                        localPlayerId = id; 
                        console.log(`[SUCCESS] I am a CLIENT with ID: ${id}`); 
                        statusMessage.textContent = 'Connecting to host...'; 
                        const connToHost = peer.connect(HOST_ID, { reliable: true }); 
                        // --- FIX: Pass the client's name to setupConnection to use it later ---
                        setupConnection(connToHost, name); 
                        // --- FIX: DO NOT call finalizeGameEntry here. Wait for connection to be open. ---
                    }); 
                    peer.on('error', (clientErr) => { 
                        console.error('[FATAL CLIENT ERROR]', clientErr); 
                        statusMessage.textContent = `Error: ${clientErr.type}. Please refresh.`; 
                    }); 
                } else { 
                    console.error('[FATAL HOST ERROR]', err); 
                    statusMessage.textContent = `Error: ${err.type}. Check server or refresh.`; 
                } 
            }); 
        }

        function finalizeGameEntry(name) { 
            loginScreen.style.display = 'none'; 
            gameContainer.style.display = 'block'; 
            createPlayer(localPlayerId, name, true); 
            players[localPlayerId].el.classList.add('local-player'); 
            if (isHost) { 
                players[localPlayerId].isHost = true; 
                for (let i = 0; i < MAX_NPCS; i++) { spawnNpc(); } 
            } else { 
                // This now runs AFTER the connection is open, so hostConn will be ready.
                const hostConn = connections[HOST_ID]; 
                if (hostConn && hostConn.open) { 
                    sendData({ type: 'sync-request', name: players[localPlayerId].name }); 
                }
            } 
            startGame(); 
        }

        // --- FIX: `nameForClient` is a new parameter for handling the race condition ---
        function setupConnection(conn, nameForClient = null) {
            connections[conn.peer] = conn;
            conn.on('data', (data) => handleData(data, conn.peer));
            conn.on('close', () => { const disconnectedPlayerName = players[conn.peer]?.name || `${conn.peer.slice(0,6)}...`; addChatMessage(`${disconnectedPlayerName} has disconnected.`, 'system'); removePlayer(conn.peer); delete connections[conn.peer]; if (isHost) { broadcast({ type: 'disconnect', id: conn.peer }); } });
            conn.on('error', (err) => { console.error(`Connection error with ${conn.peer}:`, err); });

            // --- FIX: This is the core of the solution. ---
            // If we are a client connecting to the host, wait for the connection to be fully open
            // before we finalize entry into the game.
            if (nameForClient) { // A name is only passed for the client's initial connection
                conn.on('open', () => {
                    console.log("Connection to host is now open. Finalizing game entry.");
                    finalizeGameEntry(nameForClient);
                });
            }
        }

        function sendData(data) { if (isHost) { handleData(data, localPlayerId); } else { const hostConn = connections[HOST_ID]; if (hostConn && hostConn.open) { hostConn.send(data); } } }
        function broadcast(data) { Object.values(connections).forEach(conn => { if (conn && conn.open) { conn.send(data); } }); }

        function getSerializablePlayer(player) { return { id: player.id, name: player.name, x: player.x, y: player.y, health: player.health, mana: player.mana, maxMana: player.maxMana, isDead: player.isDead, gold: player.gold, inventory: player.inventory, buffs: player.buffs, title: player.title, pvpKills: player.pvpKills, pveKills: player.pveKills, deaths: player.deaths, isHost: player.isHost }; }
        function getSerializableNpc(npc) { return { id: npc.id, x: npc.x, y: npc.y, health: npc.health, maxHealth: npc.maxHealth, isDead: npc.isDead }; }
        function isPlayerOnShrine(player) { const d = Math.hypot((SHRINE_X + SHRINE_RADIUS) - (player.x + PLAYER_RADIUS), (SHRINE_Y + SHRINE_RADIUS) - (player.y + PLAYER_RADIUS)); return d < SHRINE_RADIUS; }
        function isEntityInSafeZone(entity) { return entity.x >= SAFE_ZONE_START_X && entity.x < SAFE_ZONE_END_X; }
        function hostAnnounce(message) { if (!isHost) return; addChatMessage(message, 'system'); broadcast({ type: 'chat', name: 'system', message: message }); }
        function triggerAnimation(element, animationClass) { if (!element) return; element.classList.add(animationClass); setTimeout(() => { element.classList.remove(animationClass); }, 500); }
        function messagePlayer(playerId, message) { if (!isHost) return; if (playerId === localPlayerId) { addChatMessage(message, "system"); } else if (connections[playerId]) { connections[playerId].send({ type: 'chat', name: 'system', message: message }); } }

        function handlePlayerDeath(killedPlayer, killer) { if (!isHost || killedPlayer.gold <= 0) return; let amountToDrop = 0; const isKillerNpc = killer.id.startsWith('npc_'); if (isKillerNpc) { amountToDrop = Math.floor(killedPlayer.gold / 2); } else { amountToDrop = killedPlayer.gold; } if (amountToDrop > 0) { killedPlayer.gold -= amountToDrop; broadcast({ type: 'update-gold', playerId: killedPlayer.id, gold: killedPlayer.gold }); const angle = Math.random() * 2 * Math.PI, radius = Math.random() * GOLD_DROP_RADIUS; const dropX = (killedPlayer.x + PLAYER_RADIUS + Math.cos(angle) * radius) - (GOLD_PILE_SIZE / 2); const dropY = (killedPlayer.y + PLAYER_RADIUS + Math.sin(angle) * radius) - (GOLD_PILE_SIZE / 2); const itemId = `gold_${Date.now()}_${Math.random()}`; const item = { id: itemId, type: 'gold', amount: amountToDrop, x: dropX, y: dropY }; createWorldItem(item); broadcast({ type: 'spawn-item', item: item }); hostAnnounce(`${killedPlayer.name} dropped ${amountToDrop} gold!`); } }
        function setPlayerInCombat(player) { if (!player) return; player.lastCombatTime = Date.now(); if (!player.isInCombat) { player.isInCombat = true; broadcast({ type: 'combat-status-update', playerId: player.id, inCombat: true }); player.el.classList.add('in-combat'); } }
        function updateCombatTimers() { if (!isHost) return; for (const id in players) { const player = players[id]; if (player.isInCombat && (Date.now() - player.lastCombatTime > COMBAT_TIMEOUT)) { player.isInCombat = false; player.lastCombatTime = null; broadcast({ type: 'combat-status-update', playerId: player.id, inCombat: false }); player.el.classList.remove('in-combat'); } } }
        
        /**
         * This function, run by the host, handles player resurrection.
         * It checks every dead player to see if they are standing on the shrine.
         * If they are, it begins a resurrection timer. If they stay for the full duration, they are brought back to life.
         */
        function updateResurrections() { 
            if (!isHost) return; 
            for (const id in players) { 
                const player = players[id]; 
                if (player.isDead) { 
                    const isOnShrine = isPlayerOnShrine(player); 
                    if (isOnShrine && !player.resurrectionStartTime) { 
                        player.resurrectionStartTime = Date.now(); 
                        messagePlayer(id, "You feel the shrine's power begin to restore your life force..."); 
                    } else if (!isOnShrine && player.resurrectionStartTime) { 
                        player.resurrectionStartTime = null; 
                        messagePlayer(id, "You moved away and broke the connection to the shrine."); 
                    } else if (isOnShrine && player.resurrectionStartTime && (Date.now() - player.resurrectionStartTime >= RESURRECTION_TIME)) { 
                        player.health = MAX_HEALTH; 
                        player.isDead = false; 
                        player.resurrectionStartTime = null; 
                        hostAnnounce(`${player.name} has been resurrected!`); 
                        broadcast({ type: 'update-health', id: id, health: player.health, isDead: player.isDead }); 
                    } 
                } 
            } 
        }
        
        function updateIdlePlayers() {
            if (!isHost) return;
            const now = Date.now();
            for (const id in players) {
                const player = players[id];
                if (!player.isDead && !player.isIdleKicked && (now - player.lastInputTime > IDLE_TIMEOUT)) {
                    player.isIdleKicked = true;
                    const idleX = IDLE_ZONE.x + Math.random() * (IDLE_ZONE.width - PLAYER_SIZE);
                    const idleY = IDLE_ZONE.y + Math.random() * (IDLE_ZONE.height - PLAYER_SIZE);
                    player.x = idleX;
                    player.y = idleY;
                    hostAnnounce(`${player.name} was moved to the idle area for being inactive.`);
                    broadcast({ type: 'move', id: player.id, x: player.x, y: player.y });
                }
            }
        }

        function checkAndHandleItemPickup(player) { if (player.isDead) return; const PLAYER_PICKUP_RADIUS = PLAYER_RADIUS + 5; for (const itemId in worldItems) { const item = worldItems[itemId]; const distance = Math.hypot(player.x + PLAYER_RADIUS - (item.x + GOLD_PILE_SIZE / 2), player.y + PLAYER_RADIUS - (item.y + GOLD_PILE_SIZE / 2)); if (distance < PLAYER_PICKUP_RADIUS) { if (item.type === 'gold') { player.gold += item.amount; } removeWorldItem(itemId); broadcast({ type: 'remove-item', id: itemId }); broadcast({ type: 'update-gold', playerId: player.id, gold: player.gold }); hostAnnounce(`${player.name} picked up ${item.amount} gold.`); break; } } }
        function updateBuffs() { if (!isHost) return; const now = Date.now(); for (const pId in players) { const player = players[pId]; for (const buffType in player.buffs) { if (buffType === 'poison') continue; const buff = player.buffs[buffType]; if (buff.active && now > buff.endTime) { buff.active = false; messagePlayer(pId, `Your ${buffType.replace('_', ' ')} potion has worn off.`); broadcast({ type: 'buff-update', playerId: pId, buffs: player.buffs }); } } } }
        function checkAndAwardTitle(player) { if (!isHost) return; let bestTitle = ""; for (const titleName in TITLE_DEFINITIONS) { const def = TITLE_DEFINITIONS[titleName]; if (player[def.requirement] >= def.value) { bestTitle = titleName; } } if (bestTitle && player.title !== bestTitle) { player.title = bestTitle; hostAnnounce(`${player.name} has earned the title: ${bestTitle}!`); broadcast({ type: 'title-update', playerId: player.id, title: player.title }); } }
        function generateAndBroadcastLeaderboard() { if (!isHost) return; const sortedPlayers = Object.values(players).sort((a, b) => b.gold - a.gold); const topPlayers = sortedPlayers.slice(0, 5); let leaderboardMessage = "--- Top Brawlers (by Gold) ---"; if (topPlayers.length === 0) { leaderboardMessage += "\nNo brawlers yet!"; } else { topPlayers.forEach((p, index) => { const titleText = p.title ? ` ${p.title}` : ''; leaderboardMessage += `\n#${index + 1}: ${p.name}${titleText} - ${p.gold}g`; }); } hostAnnounce(leaderboardMessage); }
        function updateManaRegen() { if (!isHost) return; for (const pId in players) { const player = players[pId]; if (!player.isDead && player.mana < player.maxMana) { player.mana = Math.min(player.maxMana, player.mana + MANA_REGEN_RATE); broadcast({ type: 'update-mana', playerId: pId, mana: player.mana }); if (pId === localPlayerId) { players[localPlayerId].mana = player.mana; } } } }
        
        function interruptSpell(player, reason = "interrupted") {
            if (!player || !player.isCasting) return;
            clearTimeout(player.castingTimeoutId);
            player.isCasting = false;
            const spellName = SPELLS[player.castingSpellId]?.name || "spell";
            const fizzleMessage = `Your ${spellName} spell was ${reason}!`;
            messagePlayer(player.id, fizzleMessage);
            broadcast({ type: 'cast-finished', casterId: player.id });
            broadcast({ type: 'spell-fizzle', casterId: player.id }); 
            const interruptedCaster = players[player.id];
            if (interruptedCaster) {
                interruptedCaster.spellText.style.opacity = '0';
                interruptedCaster.spellText.style.marginBottom = '40px';
                if (isHost) { showFizzleEffect(interruptedCaster); } 
            }
        }

        function updatePoisonEffects() {
            if (!isHost) return;
            const now = Date.now();
            const allEntities = [...Object.values(players), ...Object.values(npcs)];

            for (const entity of allEntities) {
                if (entity.buffs?.poison?.active) {
                    const poisonData = entity.buffs.poison;
                    if (now > poisonData.endTime) {
                        poisonData.active = false;
                        if (entity.name) messagePlayer(entity.id, "The poison has worn off.");
                        broadcast({ type: 'buff-update', playerId: entity.id, buffs: entity.buffs });
                        continue;
                    }

                    if (now - poisonData.lastTickTime >= poisonData.tickInterval) {
                        poisonData.lastTickTime = now;
                        if (entity.isDead) continue;
                        
                        entity.health -= poisonData.tickDamage;
                        entity.health = Math.max(0, entity.health);
                        triggerAnimation(entity.el, 'damage-flash');
                        
                        const isTargetPlayer = !!entity.name;
                        if (isTargetPlayer) { messagePlayer(entity.id, `You take ${poisonData.tickDamage} damage from poison.`); }
                        if (entity.isCasting) { interruptSpell(entity, "interrupted by poison"); }
                        
                        if (entity.health <= 0) {
                            entity.isDead = true;
                            const targetName = entity.name || 'a slime';
                            const poisoner = players[poisonData.casterId];
                            hostAnnounce(`${targetName} has succumbed to poison!`);
                            
                            if (isTargetPlayer) {
                                entity.deaths++; checkAndAwardTitle(entity);
                                if(poisoner) { poisoner.pvpKills++; checkAndAwardTitle(poisoner); }
                                handlePlayerDeath(entity, poisoner || {id: 'npc_poison'});
                            } else {
                                if(poisoner) { poisoner.pveKills++; checkAndAwardTitle(poisoner); }
                                const dropX = entity.x + (PLAYER_RADIUS - GOLD_PILE_SIZE/2), dropY = entity.y + (PLAYER_RADIUS - GOLD_PILE_SIZE/2);
                                const item = { id: `gold_${Date.now()}_${Math.random()}`, type: 'gold', amount: SLIME_GOLD_DROP, x: dropX, y: dropY };
                                createWorldItem(item); broadcast({ type: 'spawn-item', item: item });
                                setTimeout(() => { if (npcs[entity.id]) { removeNpc(entity.id); broadcast({ type: 'despawn-npc', id: entity.id }); } }, 5000);
                                setTimeout(() => { spawnNpc(); }, 20000);
                            }
                        }
                        const updateType = isTargetPlayer ? 'update-health' : 'npc-update-health';
                        broadcast({ type: updateType, id: entity.id, health: entity.health, isDead: entity.isDead });
                    }
                }
            }
        }


        function lineIntersectsLine(p1, p2, p3, p4) {
            const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (den === 0) return false; 
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;
            return t > 0 && t < 1 && u > 0 && u < 1;
        }

        function isLineOfSightClear(startPoint, endPoint) {
            for (const building of BUILDINGS) {
                const bTopLeft = { x: building.x, y: building.y };
                const bTopRight = { x: building.x + building.width, y: building.y };
                const bBottomLeft = { x: building.x, y: building.y + building.height };
                const bBottomRight = { x: building.x + building.width, y: building.y + building.height };

                if (lineIntersectsLine(startPoint, endPoint, bTopLeft, bTopRight) ||
                    lineIntersectsLine(startPoint, endPoint, bTopRight, bBottomRight) ||
                    lineIntersectsLine(startPoint, endPoint, bBottomRight, bBottomLeft) ||
                    lineIntersectsLine(startPoint, endPoint, bBottomLeft, bTopLeft)) {
                    return false; 
                }
            }
            return true;
        }

        function handleData(data, senderId) {
            if (!isHost) {
                 switch (data.type) {
                    case 'sync-response': Object.values(data.players).forEach(p => { if(p.id !== localPlayerId) createPlayer(p.id, p.name, false, p) }); if (data.npcs) { Object.values(data.npcs).forEach(n => createNpc(n)); } if (data.items) { Object.values(data.items).forEach(i => createWorldItem(i)); } break;
                    case 'despawn-npc': const npcToFade = npcs[data.id]; if (npcToFade && npcToFade.el) { npcToFade.el.style.opacity = '0'; setTimeout(() => { removeNpc(data.id); }, 500); } break;
                    case 'new-player': if (data.id !== localPlayerId) createPlayer(data.id, data.player.name, false, data.player); break;
                    case 'move': if (players[data.id] && data.id !== localPlayerId) { players[data.id].targetX = data.x; players[data.id].targetY = data.y; } break;
                    case 'update-health': const damagedPlayer = players[data.id]; if (damagedPlayer) { triggerAnimation(damagedPlayer.el, 'damage-flash'); damagedPlayer.health = data.health; damagedPlayer.isDead = data.isDead; } break;
                    case 'update-gold': if (players[data.playerId]) { players[data.playerId].gold = data.gold; } break;
                    case 'chat': addChatMessage(data.message, data.name); if (data.playerId && data.name !== 'system') { showSpeechBubble(data.playerId, data.message); } break;
                    case 'disconnect': removePlayer(data.id); break;
                    case 'spawn-npc': createNpc(data.npc); break;
                    case 'npc-move': if (npcs[data.id]) { npcs[data.id].x = data.x; npcs[data.id].y = data.y; } break;
                    case 'npc-update-health': const damagedNpc = npcs[data.id]; if (damagedNpc) { triggerAnimation(damagedNpc.el, 'damage-flash'); damagedNpc.health = data.health; damagedNpc.isDead = data.isDead; } break;
                    case 'spawn-item': createWorldItem(data.item); break;
                    case 'remove-item': removeWorldItem(data.id); break;
                    case 'combat-status-update': const p = players[data.playerId]; if (p) { p.isInCombat = data.inCombat; p.el.classList.toggle('in-combat', data.inCombat); } break;
                    case 'update-inventory': if (players[data.playerId]) { players[data.playerId].inventory = data.inventory; } break;
                    case 'buff-update': const entity = players[data.playerId] || npcs[data.playerId]; if (entity) { if (!entity.buffs) entity.buffs = {}; entity.buffs = data.buffs; } break;
                    case 'title-update': if (players[data.playerId]) { players[data.playerId].title = data.title; } break;
                    case 'update-mana': if (players[data.playerId]) { players[data.playerId].mana = data.mana; } break;
                    case 'cast-started': const caster = players[data.casterId]; if (caster) { caster.spellText.textContent = data.spell.words; caster.spellText.style.opacity = '1'; caster.spellText.style.marginBottom = '45px'; } break;
                    case 'cast-finished': const finishedCaster = players[data.casterId]; if (finishedCaster) { finishedCaster.spellText.style.opacity = '0'; finishedCaster.spellText.style.marginBottom = '40px'; } break;
                    case 'spell-effect': const targetEl = players[data.targetId]?.el || npcs[data.targetId]?.el; if (targetEl) { showSpellEffect(targetEl, data.spellId); } break;
                    case 'spawn-projectile': createProjectile(data.projectileId, data.casterId, data.targetId, data.spellId, data.travelTime); break;
                    case 'spell-fizzle': const fizzleCaster = players[data.casterId]; if (fizzleCaster) { showFizzleEffect(fizzleCaster); } break;
                }
                return;
            }

            const senderPlayer = players[senderId];
            if (!senderPlayer && data.type !== 'sync-request') return;

            switch (data.type) {
                case 'sync-request': const serializablePlayers = {}; for (const pId in players) { serializablePlayers[pId] = getSerializablePlayer(players[pId]); } const serializableNpcs = {}; for (const nId in npcs) { serializableNpcs[nId] = getSerializableNpc(npcs[nId]); } connections[senderId].send({ type: 'sync-response', players: serializablePlayers, npcs: serializableNpcs, items: worldItems }); const newPlayer = createPlayer(senderId, data.name); broadcast({ type: 'new-player', id: senderId, player: getSerializablePlayer(newPlayer) }); break;
                case 'move':
                    senderPlayer.x = data.x; senderPlayer.y = data.y; senderPlayer.lastInputTime = Date.now(); senderPlayer.isIdleKicked = false; checkAndHandleItemPickup(senderPlayer); broadcast({ type: 'move', id: senderId, x: data.x, y: data.y }); break;
                case 'attack':
                    if (senderPlayer.isDead) return;
                    let target, targetName, damageSource;
                    if (data.targetType === 'player') { target = players[data.targetId]; targetName = target?.name || 'someone'; } else if (data.targetType === 'npc') { target = npcs[data.targetId]; targetName = 'a slime'; }
                    damageSource = senderPlayer.name;
                    const currentAttackDamage = (senderPlayer.buffs.damage.active ? PLAYER_BASE_ATTACK_DAMAGE + 5 : PLAYER_BASE_ATTACK_DAMAGE);
                    setPlayerInCombat(senderPlayer);
                    if (target && isEntityInSafeZone(target)) { return; }
                    if (target && !target.isDead) {
                            if (data.targetType === 'player') { setPlayerInCombat(target); if (target.isCasting) { interruptSpell(target, "interrupted by damage"); } }
                            target.health -= currentAttackDamage; hostAnnounce(`${damageSource} attacks ${targetName}!`);
                            if(target.health <= 0) { target.health = 0; target.isDead = true; hostAnnounce(`${targetName} has been slain!`); target.deaths++; checkAndAwardTitle(target); if (data.targetType === 'player') { senderPlayer.pvpKills++; checkAndAwardTitle(senderPlayer); handlePlayerDeath(target, senderPlayer); } else if (data.targetType === 'npc') { senderPlayer.pveKills++; checkAndAwardTitle(senderPlayer); const dropX = target.x + (PLAYER_RADIUS - GOLD_PILE_SIZE/2), dropY = target.y + (PLAYER_RADIUS - GOLD_PILE_SIZE/2); const item = { id: `gold_${Date.now()}_${Math.random()}`, type: 'gold', amount: SLIME_GOLD_DROP, x: dropX, y: dropY }; createWorldItem(item); broadcast({ type: 'spawn-item', item: item }); setTimeout(() => { if (npcs[data.targetId]) { removeNpc(data.targetId); broadcast({ type: 'despawn-npc', id: data.targetId }); } }, 5000); setTimeout(() => { spawnNpc(); }, 20000); } }
                            const updateType = data.targetType === 'player' ? 'update-health' : 'npc-update-health';
                            broadcast({ type: updateType, id: data.targetId, health: target.health, isDead: target.isDead, attackerId: senderId });
                            triggerAnimation(target.el, 'damage-flash');
                    }
                    break;
                case 'buy-item': const itemToBuy = VENDOR_ITEMS[data.itemId]; if (!itemToBuy) return; if (senderPlayer.gold >= itemToBuy.cost) { senderPlayer.gold -= itemToBuy.cost; senderPlayer.inventory[data.itemId]++; messagePlayer(senderId, `You purchased a ${data.itemId.replace('_', ' ')}.`); broadcast({ type: 'update-gold', playerId: senderId, gold: senderPlayer.gold }); broadcast({ type: 'update-inventory', playerId: senderId, inventory: senderPlayer.inventory }); } else { messagePlayer(senderId, "You don't have enough gold for that."); } break;
                case 'use-item': if (senderPlayer.isDead) return; if (senderPlayer.inventory[data.itemId] > 0) { senderPlayer.inventory[data.itemId]--; switch (data.itemId) { case 'health_potion': senderPlayer.health = Math.min(MAX_HEALTH, senderPlayer.health + HEALING_POTION_AMOUNT); messagePlayer(senderId, "You feel healthier."); broadcast({ type: 'update-health', id: senderId, health: senderPlayer.health, isDead: senderPlayer.isDead }); break; case 'speed_potion': senderPlayer.buffs.speed.active = true; senderPlayer.buffs.speed.endTime = Date.now() + BUFF_DURATION; messagePlayer(senderId, "You feel faster!"); broadcast({ type: 'buff-update', playerId: senderId, buffs: senderPlayer.buffs }); break; case 'damage_potion': senderPlayer.buffs.damage.active = true; senderPlayer.buffs.damage.endTime = Date.now() + BUFF_DURATION; messagePlayer(senderId, "You feel stronger!"); broadcast({ type: 'buff-update', playerId: senderId, buffs: senderPlayer.buffs }); break; } broadcast({ type: 'update-inventory', playerId: senderId, inventory: senderPlayer.inventory }); } break;
                case 'chat': if (senderPlayer) { senderPlayer.lastInputTime = Date.now(); senderPlayer.isIdleKicked = false; } if (data.message.trim().toLowerCase() === '/top') { generateAndBroadcastLeaderboard(); } else { const chatData = { type: 'chat', playerId: senderId, name: senderPlayer.name, message: data.message }; addChatMessage(chatData.message, chatData.name); showSpeechBubble(chatData.playerId, chatData.message); broadcast(chatData); } break;
                case 'start-cast':
                    if (senderPlayer.isDead) return;
                    if (!senderPlayer || !data.targetId || !data.spellId) return;
                    const spell = SPELLS[data.spellId]; const castTarget = players[data.targetId] || npcs[data.targetId];
                    if (senderPlayer.isCasting) return;
                    if (!spell || !castTarget || castTarget.isDead) return;
                    if (senderPlayer.mana < spell.manaCost) { messagePlayer(senderId, "You don't have enough mana."); return; }
                    if (Math.hypot(senderPlayer.x - castTarget.x, senderPlayer.y - castTarget.y) > SPELL_RANGE) { messagePlayer(senderId, "Your target is too far away."); return; }
                    senderPlayer.isCasting = true; senderPlayer.castingSpellId = data.spellId; senderPlayer.castingTargetId = data.targetId; senderPlayer.mana -= spell.manaCost;
                    broadcast({ type: 'update-mana', playerId: senderId, mana: senderPlayer.mana });
                    if (senderId === localPlayerId) players[localPlayerId].mana = senderPlayer.mana;
                    broadcast({ type: 'cast-started', casterId: senderId, spell: spell });
                    if (players[senderId]) { players[senderId].spellText.textContent = spell.words; players[senderId].spellText.style.opacity = '1'; players[senderId].spellText.style.marginBottom = '45px'; }
                    senderPlayer.castingTimeoutId = setTimeout(() => {
                        if (!senderPlayer.isCasting) return;
                        const finalTarget = players[senderPlayer.castingTargetId] || npcs[senderPlayer.castingTargetId];
                        if (!finalTarget || finalTarget.isDead) { interruptSpell(senderPlayer, "as the target is gone"); return; }
                        const casterCenter = { x: senderPlayer.x + PLAYER_RADIUS, y: senderPlayer.y + PLAYER_RADIUS };
                        const targetCenter = { x: finalTarget.x + PLAYER_RADIUS, y: finalTarget.y + PLAYER_RADIUS };
                        if (!isLineOfSightClear(casterCenter, targetCenter)) { interruptSpell(senderPlayer, "as the target is not in your line of sight"); return; }
                        senderPlayer.isCasting = false; broadcast({ type: 'cast-finished', casterId: senderId });
                        if (players[senderId]) { players[senderId].spellText.style.opacity = '0'; players[senderId].spellText.style.marginBottom = '40px'; }
                        const distance = Math.hypot(senderPlayer.x - finalTarget.x, senderPlayer.y - finalTarget.y);
                        const travelTime = (distance / PROJECTILE_SPEED) * 1000;
                        const projectileId = `proj_${Date.now()}`;
                        const spawnData = { type: 'spawn-projectile', projectileId, casterId: senderId, targetId: finalTarget.id, spellId: data.spellId, travelTime };
                        broadcast(spawnData); createProjectile(spawnData.projectileId, spawnData.casterId, spawnData.targetId, spawnData.spellId, spawnData.travelTime);
                        
                        setTimeout(() => {
                            const hitTarget = players[finalTarget.id] || npcs[finalTarget.id];
                            if (!hitTarget || hitTarget.isDead) return;
                            
                            const isTargetPlayer = !!hitTarget.name;
                            setPlayerInCombat(senderPlayer);
                            if (isTargetPlayer) { setPlayerInCombat(hitTarget); }
                           
                            if (data.spellId === 'poison') {
                                if (!hitTarget.buffs) hitTarget.buffs = {};
                                hitTarget.buffs.poison = { active: true, endTime: Date.now() + 10000, lastTickTime: Date.now(), tickInterval: 2000, tickDamage: 2, casterId: senderId };
                                hostAnnounce(`${senderPlayer.name}'s poison spell envelops ${hitTarget.name || 'a slime'}!`);
                                broadcast({ type: 'buff-update', playerId: hitTarget.id, buffs: hitTarget.buffs });
                            } else {
                                if (isTargetPlayer && hitTarget.isCasting) { interruptSpell(hitTarget, "interrupted by a spell"); }
                                hitTarget.health -= spell.damage;
                                hostAnnounce(`${senderPlayer.name}'s ${spell.name} hits ${hitTarget.name || 'a slime'} for ${spell.damage} damage!`);
                                if (hitTarget.health <= 0) {
                                    hitTarget.health = 0; hitTarget.isDead = true;
                                    const targetName = hitTarget.name || 'a slime';
                                    hostAnnounce(`${targetName} has been slain!`);
                                    if (isTargetPlayer) { hitTarget.deaths++; checkAndAwardTitle(hitTarget); senderPlayer.pvpKills++; checkAndAwardTitle(senderPlayer); handlePlayerDeath(hitTarget, senderPlayer); }
                                    else { senderPlayer.pveKills++; checkAndAwardTitle(senderPlayer); const dropX = hitTarget.x + (PLAYER_RADIUS - GOLD_PILE_SIZE / 2); const dropY = hitTarget.y + (PLAYER_RADIUS - GOLD_PILE_SIZE / 2); const item = { id: `gold_${Date.now()}_${Math.random()}`, type: 'gold', amount: SLIME_GOLD_DROP, x: dropX, y: dropY }; createWorldItem(item); broadcast({ type: 'spawn-item', item: item }); setTimeout(() => { if (npcs[hitTarget.id]) { removeNpc(hitTarget.id); broadcast({ type: 'despawn-npc', id: hitTarget.id }); } }, 5000); setTimeout(() => { spawnNpc(); }, 20000); }
                                }
                                const updateType = isTargetPlayer ? 'update-health' : 'npc-update-health';
                                broadcast({ type: updateType, id: hitTarget.id, health: hitTarget.health, isDead: hitTarget.isDead, attackerId: senderId });
                                if (isHost) triggerAnimation(hitTarget.el, 'damage-flash');
                            }
                            
                            broadcast({ type: 'spell-effect', targetId: hitTarget.id, spellId: data.spellId });
                            if (isHost) showSpellEffect(hitTarget.el, data.spellId);
                        }, travelTime);

                    }, spell.castTime);
                    break;
            }
        }
        
        function createPlayer(id, name, isLocal = false, initialState = {}) {
            if (players[id]) return players[id];
            const spawnPoint = initialState.x != null ? {x: initialState.x, y: initialState.y} : getSafeSpawnPoint();
            const playerState = { id: id, el: document.createElement('div'), nameTag: document.createElement('div'), healthBar: document.createElement('div'), healthBarInner: document.createElement('div'), speechBubble: document.createElement('div'), spellText: document.createElement('div'), name: name, x: spawnPoint.x, y: spawnPoint.y, targetX: spawnPoint.x, targetY: spawnPoint.y, health: initialState.health ?? MAX_HEALTH, mana: initialState.mana ?? MAX_MANA, maxMana: MAX_MANA, isCasting: false, castingSpellId: null, castingTargetId: null, castingTimeoutId: null, isDead: initialState.isDead ?? false, gold: initialState.gold ?? 0, inventory: initialState.inventory ?? { health_potion: 0, speed_potion: 0, damage_potion: 0 }, buffs: initialState.buffs ?? { speed: { active: false, endTime: 0 }, damage: { active: false, endTime: 0 }, poison: { active: false } }, title: initialState.title ?? '', pvpKills: initialState.pvpKills ?? 0, pveKills: initialState.pveKills ?? 0, deaths: initialState.deaths ?? 0, resurrectionStartTime: null, isInCombat: false, lastCombatTime: null, lastInputTime: Date.now(), isIdleKicked: false, speechTimeoutId: null, isHost: initialState.isHost ?? false };
            playerState.el.className = 'game-object player-object'; playerState.el.dataset.id = id; playerState.nameTag.className = 'name-tag'; playerState.healthBar.className = 'health-bar'; playerState.healthBarInner.className = 'health-bar-inner'; playerState.speechBubble.className = 'speech-bubble'; playerState.spellText.className = 'spell-text';
            if (isLocal) { playerState.el.classList.add('local-player'); } else { playerState.el.classList.add('remote-player'); }
            playerState.healthBar.appendChild(playerState.healthBarInner); playerState.el.appendChild(playerState.nameTag); playerState.el.appendChild(playerState.healthBar); playerState.el.appendChild(playerState.speechBubble); playerState.el.appendChild(playerState.spellText);
            worldContainer.appendChild(playerState.el);
            players[id] = playerState; addChatMessage(`${name} has entered the realm.`, 'system'); return playerState;
        }
        function removePlayer(id) { if (players[id]) { players[id].el.remove(); delete players[id]; } }
        function createNpc(npcData) { if (npcs[npcData.id]) return; const npcState = { id: npcData.id, el: document.createElement('div'), healthBar: document.createElement('div'), healthBarInner: document.createElement('div'), x: npcData.x, y: npcData.y, health: npcData.health, maxHealth: npcData.maxHealth, isDead: npcData.isDead, buffs: { poison: { active: false } } }; npcState.el.className = 'game-object npc-object'; npcState.el.dataset.id = npcData.id; npcState.healthBar.className = 'health-bar'; npcState.healthBarInner.className = 'health-bar-inner'; npcState.healthBar.appendChild(npcState.healthBarInner); npcState.el.appendChild(npcState.healthBar); worldContainer.appendChild(npcState.el); npcs[npcData.id] = npcState; }
        function removeNpc(id) { if (npcs[id]) { npcs[id].el.remove(); delete npcs[id]; } }
        function createWorldItem(item) { if (worldItems[item.id]) return; const itemEl = document.createElement('div'); itemEl.className = 'game-object gold-pile'; itemEl.style.left = item.x + 'px'; itemEl.style.top = item.y + 'px'; itemEl.dataset.id = item.id; worldItems[item.id] = { ...item, el: itemEl }; worldContainer.appendChild(itemEl); }
        function removeWorldItem(id) { if (worldItems[id]) { worldItems[id].el.remove(); delete worldItems[id]; } }

        function startGame() { requestAnimationFrame(gameLoop); }
        
        function updateSailingBoat() {
            boatX += 0.5 * boatDirection;
            if (boatX > 2000 || boatX < 800) {
                boatDirection *= -1;
                sailingBoat.style.transform = `scaleX(${boatDirection})`;
            }
            sailingBoat.style.left = boatX + 'px';
            sailingBoat.style.top = boatY + 'px';
        }
        
        function gameLoop() {
            handleInput();
            handleAutoAttack();
            if (isHost) {
                updateNpcAI();
                updateResurrections();
                updateCombatTimers();
                updateIdlePlayers();
                updateBuffs();
                updatePoisonEffects();
            }
            for (const id in players) {
                if (id === localPlayerId) continue;
                const p = players[id];
                const dx = p.targetX - p.x;
                const dy = p.targetY - p.y;
                p.x += dx * INTERPOLATION_FACTOR;
                p.y += dy * INTERPOLATION_FACTOR;
            }
            
            updateSailingBoat();
            updateProjectiles();
            updateCamera();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function updateCamera() { const me = players[localPlayerId]; if (!me) return; const viewportWidth = parseInt(getComputedStyle(world).width); const viewportHeight = parseInt(getComputedStyle(world).height); cameraX = me.x - (viewportWidth / 2) + (PLAYER_SIZE / 2); cameraY = me.y - (viewportHeight / 2) + (PLAYER_SIZE / 2); cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH_ACTUAL - viewportWidth)); cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT_ACTUAL - viewportHeight)); }
        
        /**
         * Handles local player input for movement.
         * A critical feature here is that collision with players and buildings is disabled when the player `isDead`.
         * This allows the player's ghost to pass through objects to reach the resurrection shrine.
         */
        function handleInput() {
            const me = players[localPlayerId];
            if (!me || document.activeElement === chatInput || vendorMenu.style.display === 'block') { if (isMovingWithMouse) { isMovingWithMouse = false; } return; }
            let dx = 0, dy = 0;
            if (isMovingWithMouse) { dx = mouseTargetWorldPos.x - (me.x + PLAYER_RADIUS); dy = mouseTargetWorldPos.y - (me.y + PLAYER_RADIUS); } else { if (keysPressed['w']) dy--; if (keysPressed['s']) dy++; if (keysPressed['a']) dx--; if (keysPressed['d']) dx++; }
            const magnitude = Math.hypot(dx, dy);
            if (magnitude < 1) return; 
            const currentSpeed = me.buffs.speed.active ? PLAYER_BASE_SPEED * 1.5 : PLAYER_BASE_SPEED;
            let newX, newY;
            if (isMovingWithMouse) { const distanceToMove = Math.min(magnitude, currentSpeed); newX = me.x + (dx / magnitude) * distanceToMove; newY = me.y + (dy / magnitude) * distanceToMove; } else { newX = me.x + (dx / magnitude) * currentSpeed; newY = me.y + (dy / magnitude) * currentSpeed; }
            if (isPositionInWater(newX, me.y)) newX = me.x; if (isPositionInWater(me.x, newY)) newY = me.y; if (isPositionInWater(newX, newY)) { newX = me.x; newY = me.y; }
            if (!me.isDead) { Object.values(players).forEach(other => { if (other.id === localPlayerId || other.isDead) return; if (checkPlayerCollision(newX, me.y, other)) { newX = me.x; } if (checkPlayerCollision(me.x, newY, other)) { newY = me.y; } }); for (const building of BUILDINGS) { if (checkBuildingCollision(newX, me.y, building)) { newX = me.x; } if (checkBuildingCollision(me.x, newY, building)) { newY = me.y; } } }
            const originalX = me.x, originalY = me.y;
            me.x = Math.max(0, Math.min(WORLD_WIDTH_ACTUAL - PLAYER_SIZE, newX)); me.y = Math.max(0, Math.min(WORLD_HEIGHT_ACTUAL - PLAYER_SIZE, newY));
            if (me.x !== originalX || me.y !== originalY) { sendData({ type: 'move', x: me.x, y: me.y }); }
        }
        
        function handleAutoAttack() {
            if (!isAutoAttacking || !currentTargetId || attackCooldown) return;
            const me = players[localPlayerId];
            const target = players[currentTargetId] || npcs[currentTargetId];
            if (!me || me.isDead || !target || target.isDead) { clearTarget(); return; }
            const distance = Math.hypot((me.x + PLAYER_RADIUS) - (target.x + PLAYER_RADIUS), (me.y + PLAYER_RADIUS) - (target.y + PLAYER_RADIUS));
            if (distance <= ATTACK_RANGE) { const targetType = target.name ? 'player' : 'npc'; doAttack(currentTargetId, targetType); }
        }

        function handleKeyPress(e) {
            const me = players[localPlayerId];
            if (!me || me.isDead || document.activeElement === chatInput || vendorMenu.style.display === 'block') return;
            const key = e.key.toLowerCase(); 
            if (key === 'enter') { chatInput.focus(); keysPressed['enter'] = false; return; } 
            switch(key) { 
                case '1': // Poison
                case '2': // Lightning
                case '3': // Magic Arrow
                case '4': // Flamestrike
                    if (currentTargetId) { 
                        const spellId = Object.keys(SPELLS).find(id => SPELLS[id].key === key); 
                        if (spellId) {
                            sendData({ type: 'start-cast', spellId: spellId, targetId: currentTargetId }); 
                        }
                    } else { 
                        addChatMessage("You must have a target to cast a spell.", "system"); 
                    } 
                    break;
                case '6': // Healing Potion
                    sendData({ type: 'use-item', itemId: 'health_potion' }); 
                    break;
                case 'tab': e.preventDefault(); cycleTarget(); break; 
                case 'escape': e.preventDefault(); clearTarget(); break; 
            } 
        }
        
        function onWorldClick(e) { 
            const me = players[localPlayerId]; 
            if (!me || me.isDead) return; 
            const worldRect = world.getBoundingClientRect(); 
            const clickX = e.clientX - worldRect.left + cameraX; const clickY = e.clientY - worldRect.top + cameraY; 
            const distToVendor = Math.hypot(clickX - (VENDOR_X + VENDOR_SIZE/2), clickY - (VENDOR_Y + VENDOR_SIZE/2)); 
            if (distToVendor < VENDOR_SIZE / 2) { 
                const distPlayerToVendor = Math.hypot((me.x + PLAYER_RADIUS) - (VENDOR_X + VENDOR_SIZE/2), (me.y + PLAYER_RADIUS) - (VENDOR_Y + VENDOR_SIZE/2)); 
                if (distPlayerToVendor < VENDOR_INTERACT_RANGE) { vendorMenu.style.display = 'block'; } else { addChatMessage("You are too far away from the vendor.", "system"); } 
                isMovingWithMouse = false; return; 
            } 
            let foundTargetId = null, foundTargetName = '';
            for (const p of Object.values(players)) { if (p.id !== localPlayerId && !p.isDead && clickX >= p.x && clickX <= p.x + PLAYER_SIZE && clickY >= p.y && clickY <= p.y + PLAYER_SIZE) { foundTargetId = p.id; foundTargetName = p.name; break; } } 
            if (!foundTargetId) { for (const n of Object.values(npcs)) { if (!n.isDead && clickX >= n.x && clickX <= n.x + PLAYER_SIZE && clickY >= n.y && clickY <= n.y + PLAYER_SIZE) { foundTargetId = n.id; foundTargetName = 'a slime'; break; } } } 
            if (foundTargetId) { isMovingWithMouse = false; currentTargetId = foundTargetId; isAutoAttacking = true; addChatMessage(`You begin attacking ${foundTargetName}.`, 'system'); } else { if (isAutoAttacking) { addChatMessage('You are no longer attacking.', 'system'); } isAutoAttacking = false; } 
        }

        function doAttack(targetId, targetType) { 
            const me = players[localPlayerId]; 
            if (!me || me.isDead || attackCooldown) return; 
            if (isPlayerOnShrine(me)) { addChatMessage("You feel a sense of peace and cannot attack while on the shrine.", "system"); return; } 
            let target; 
            if (targetType === 'player') { target = players[targetId]; } else if (targetType === 'npc') { target = npcs[targetId]; } 
            if (!target || target.isDead) { clearTarget(); return; } 
            if (isEntityInSafeZone(target)) { addChatMessage("That target is in a safe zone.", "system"); clearTarget(); return; } 
            const distance = Math.hypot((me.x + PLAYER_RADIUS) - (target.x + PLAYER_RADIUS), (me.y + PLAYER_RADIUS) - (target.y + PLAYER_RADIUS)); 
            if (distance <= ATTACK_RANGE) { 
                triggerAnimation(me.el, 'melee-attack-lunge');
                sendData({ type: 'attack', targetId: targetId, targetType: targetType }); 
            } else { 
                addChatMessage('You are too far away to attack.', 'system'); 
                return; 
            } 
            attackCooldown = true; 
            setTimeout(() => { attackCooldown = false; }, ATTACK_COOLDOWN_MS); 
        }
        
        function checkPlayerCollision(p1x, p1y, otherPlayer) { const distance = Math.hypot((p1x + PLAYER_RADIUS) - (otherPlayer.x + PLAYER_RADIUS), (p1y + PLAYER_RADIUS) - (otherPlayer.y + PLAYER_RADIUS)); return distance < PLAYER_SIZE; }
        
        function checkBuildingCollision(objectX, objectY, building) {
            return (objectX < building.x + building.width && objectX + PLAYER_SIZE > building.x && objectY < building.y + building.height && objectY + PLAYER_SIZE > building.y);
        }

        function cycleTarget() {
            const me = players[localPlayerId]; if (!me) return;
            const allTargets = [...Object.values(players), ...Object.values(npcs)];
            const validTargets = allTargets.filter(t => t.id !== localPlayerId && !t.isDead && !isEntityInSafeZone(t)).map(t => ({ ...t, dist: Math.hypot(me.x - t.x, me.y - t.y) })).filter(t => t.dist < 400).sort((a, b) => a.dist - b.dist);
            if (validTargets.length === 0) { clearTarget(); return; }
            const currentIndex = validTargets.findIndex(t => t.id === currentTargetId);
            const nextIndex = (currentIndex + 1) % validTargets.length;
            currentTargetId = validTargets[nextIndex].id; isAutoAttacking = true;
            const targetName = validTargets[nextIndex].name || 'a slime'; addChatMessage(`You begin attacking ${targetName}.`, 'system');
        }

        function clearTarget() { if (isAutoAttacking) { addChatMessage('You are no longer attacking.', 'system'); } isAutoAttacking = false; currentTargetId = null; }

        function updateNpcAI() { 
            if (!isHost) return; 
            for (const id in npcs) { 
                const npc = npcs[id]; if (npc.isDead) continue; let targetPlayer = null; let minDistance = NPC_AGGRO_RANGE; 
                for (const pId in players) { const player = players[pId]; if (player.isDead || isEntityInSafeZone(player)) continue; const distance = Math.hypot(npc.x - player.x, npc.y - player.y); if (distance < minDistance) { minDistance = distance; targetPlayer = player; } } 
                let hasMoved = false; 
                if (targetPlayer) { 
                    if (minDistance > NPC_ATTACK_RANGE) { 
                        const dx = targetPlayer.x - npc.x, dy = targetPlayer.y - npc.y; const magnitude = Math.hypot(dx, dy); 
                        let nextX = npc.x + (dx / magnitude) * NPC_SLIME_SPEED; let nextY = npc.y + (dy / magnitude) * NPC_SLIME_SPEED; 
                        for (const building of BUILDINGS) { if (checkBuildingCollision(nextX, npc.y, building)) { nextX = npc.x; } if (checkBuildingCollision(npc.x, nextY, building)) { nextY = npc.y; } }
                        if (!isPositionInWater(nextX, nextY)) { npc.x = nextX; npc.y = nextY; hasMoved = true; } 
                    } 
                    if (minDistance <= NPC_ATTACK_RANGE && !npc.ai_attackCooldown) { 
                        setPlayerInCombat(targetPlayer); if (targetPlayer.isCasting) { interruptSpell(targetPlayer, "interrupted by damage"); } 
                        targetPlayer.health -= NPC_SLIME_DAMAGE; hostAnnounce(`A slime attacks ${targetPlayer.name}!`); 
                        if (targetPlayer.health <= 0) { targetPlayer.health = 0; targetPlayer.isDead = true; hostAnnounce(`${targetPlayer.name} has been slain by a slime!`); targetPlayer.deaths++; checkAndAwardTitle(targetPlayer); handlePlayerDeath(targetPlayer, npc); } 
                        broadcast({ type: 'update-health', id: targetPlayer.id, health: targetPlayer.health, isDead: targetPlayer.isDead, attackerId: npc.id }); 
                        triggerAnimation(targetPlayer.el, 'damage-flash'); npc.ai_attackCooldown = true; setTimeout(() => { npc.ai_attackCooldown = false; }, 1000); 
                    } 
                } 
                if (hasMoved) { npc.x = Math.max(0, Math.min(WORLD_WIDTH_ACTUAL - PLAYER_SIZE, npc.x)); npc.y = Math.max(0, Math.min(WORLD_HEIGHT_ACTUAL - PLAYER_SIZE, npc.y)); broadcast({ type: 'npc-move', id: npc.id, x: npc.x, y: npc.y }); } 
            } 
        }
        function spawnNpc() { if (!isHost) return; const spawnPoint = getSafeSpawnPoint(); const id = `npc_${Date.now()}_${Math.random()}`; const npcData = { id: id, x: spawnPoint.x, y: spawnPoint.y, health: NPC_SLIME_HEALTH, maxHealth: NPC_SLIME_HEALTH, isDead: false }; createNpc(npcData); const npcState = npcs[id]; if (npcState) { npcState.ai_lastMove = Date.now(); npcState.ai_attackCooldown = false; } broadcast({ type: 'spawn-npc', npc: getSerializableNpc(npcState) }); }

        function showSpeechBubble(playerId, message) { const player = players[playerId]; if (!player || !player.speechBubble) return; if (player.speechTimeoutId) { clearTimeout(player.speechTimeoutId); } player.speechBubble.textContent = message; player.speechBubble.style.opacity = '1'; player.speechTimeoutId = setTimeout(() => { player.speechBubble.style.opacity = '0'; }, 4000); }
        function showSpellEffect(targetEl, spellId) {
            const effectEl = document.createElement('div');
            effectEl.style.position = 'absolute'; effectEl.style.pointerEvents = 'none'; effectEl.style.zIndex = 100;
            switch(spellId) {
                case 'magic_arrow': effectEl.textContent = ''; effectEl.style.color = '#e0aaff'; effectEl.style.fontSize = '30px'; break;
                case 'lightning': effectEl.textContent = ''; effectEl.style.color = '#f0e68c'; effectEl.style.fontSize = '40px'; break;
                case 'flamestrike': effectEl.textContent = ''; effectEl.style.color = '#ff6a00'; effectEl.style.fontSize = '50px'; break;
                case 'poison': effectEl.textContent = ''; effectEl.style.color = '#4CAF50'; effectEl.style.fontSize = '40px'; break;
            }
            targetEl.appendChild(effectEl);
            setTimeout(() => effectEl.remove(), 800);
        }
        
        function showFizzleEffect(caster) {
            if (!caster) return;
            const effectEl = document.createElement('div'); effectEl.className = 'fizzle-effect';
            const effectSize = 40; const casterCenterX = caster.x + PLAYER_RADIUS; const casterCenterY = caster.y + PLAYER_RADIUS;
            effectEl.style.left = `${casterCenterX - (effectSize / 2)}px`; effectEl.style.top = `${casterCenterY - (effectSize / 2)}px`;
            worldContainer.appendChild(effectEl); setTimeout(() => { effectEl.remove(); }, 700); 
        }

        function createProjectile(id, casterId, targetId, spellId, travelTime) {
            if (projectiles[id]) return;
            const caster = players[casterId]; const target = players[targetId] || npcs[targetId];
            if (!caster || !target) return;
            const el = document.createElement('div'); el.className = 'spell-projectile';
            const spellVisuals = { 'magic_arrow': '', 'lightning': '', 'flamestrike': '', 'poison': '' };
            const spellColors = { 'magic_arrow': '#e0aaff', 'lightning': '#f0e68c', 'flamestrike': '#ff6a00', 'poison': '#4CAF50' };
            el.textContent = spellVisuals[spellId] || '';
            el.style.color = spellColors[spellId] || '#fff';
            const startX = caster.x + (PLAYER_SIZE / 2); const startY = caster.y + (PLAYER_SIZE / 2);
            el.style.left = startX + 'px'; el.style.top = startY + 'px';
            worldContainer.appendChild(el);
            projectiles[id] = { id, el, spellId, startX, startY, endX: target.x + (PLAYER_SIZE / 2), endY: target.y + (PLAYER_SIZE / 2), targetId, startTime: Date.now(), travelTime };
            setTimeout(() => { el.remove(); delete projectiles[id]; }, travelTime + 100);
        }
        function updateProjectiles() {
            const now = Date.now();
            for (const id in projectiles) {
                const p = projectiles[id]; const target = players[p.targetId] || npcs[p.targetId];
                const targetX = target ? target.x + (PLAYER_SIZE / 2) : p.endX; const targetY = target ? target.y + (PLAYER_SIZE / 2) : p.endY;
                const progress = Math.min(1, (now - p.startTime) / p.travelTime);
                p.x = p.startX + (targetX - p.startX) * progress; p.y = p.startY + (targetY - p.startY) * progress;
                p.el.style.left = p.x + 'px'; p.el.style.top = p.y + 'px';
            }
        }

        function updateUI() {
            worldContainer.style.transform = `translate(${-cameraX}px, ${-cameraY}px)`;
            document.querySelectorAll('.targeted-entity').forEach(el => el.classList.remove('targeted-entity'));
            Object.values(players).forEach(p => { 
                p.el.style.left = p.x + 'px'; 
                p.el.style.top = p.y + 'px'; 
                const hostIcon = p.isHost ? ' ' : ''; 
                p.nameTag.textContent = `${hostIcon}${p.name} ${p.title || ''}`.trim(); 
                p.healthBarInner.style.width = (p.health / MAX_HEALTH) * 100 + '%'; 
                p.el.classList.toggle('ghost', p.isDead); 
                p.el.classList.toggle('speed-buff', p.buffs.speed.active); 
                p.el.classList.toggle('damage-buff', p.buffs.damage.active); 
                p.el.classList.toggle('poisoned', p.buffs.poison?.active); 
            });
            Object.values(npcs).forEach(n => { 
                if (n.el) { 
                    n.el.style.left = n.x + 'px'; 
                    n.el.style.top = n.y + 'px'; 
                    n.healthBarInner.style.width = (n.health / n.maxHealth) * 100 + '%'; 
                    n.el.classList.toggle('ghost', n.isDead); 
                    if (n.buffs) {
                        n.el.classList.toggle('poisoned', n.buffs.poison?.active);
                    }
                } 
            });
            Object.values(worldItems).forEach(i => { if (i.el) { i.el.style.left = i.x + 'px'; i.el.style.top = i.y + 'px'; } });
            if (currentTargetId) { const target = players[currentTargetId] || npcs[currentTargetId]; if (target && !target.isDead) { target.el.classList.add('targeted-entity'); } else { clearTarget(); } }
            const me = players[localPlayerId];
            if (me) { playerGoldDisplay.textContent = `Gold: ${me.gold}`; document.getElementById('player-mana').textContent = `Mana: ${Math.floor(me.mana)}`; playerInventoryDisplay.textContent = `Pots: H[${me.inventory.health_potion}] S[${me.inventory.speed_potion}] D[${me.inventory.damage_potion}]`; }
        }
        function addChatMessage(message, sender) { const p = document.createElement('p'); if (sender === 'system') { p.className = 'system-msg'; p.innerHTML = message.replace(/\n/g, '<br>'); } else { const isLocal = players[localPlayerId] && sender === players[localPlayerId].name; p.className = isLocal ? 'my-msg' : 'their-msg'; p.textContent = `[${sender}]: ${message}`; } chatLog.appendChild(p); chatLog.scrollTop = chatLog.scrollHeight; }
        function onChatSubmit(e) { if (e.key === 'Enter') { e.preventDefault(); const message = chatInput.value; if (message) { sendData({ type: 'chat', message: message }); chatInput.value = ''; chatInput.blur(); } } }
        
        initialize();
    </script>
</body>
</html>